/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package com.xiaomi.infra.galaxy.sds.thrift;

import libthrift091.scheme.IScheme;
import libthrift091.scheme.SchemeFactory;
import libthrift091.scheme.StandardScheme;

import libthrift091.scheme.TupleScheme;
import libthrift091.protocol.TTupleProtocol;
import libthrift091.protocol.TProtocolException;
import libthrift091.EncodingUtils;
import libthrift091.TException;
import libthrift091.async.AsyncMethodCallback;
import libthrift091.server.AbstractNonblockingServer.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import javax.annotation.Generated;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@SuppressWarnings({"cast", "rawtypes", "serial", "unchecked"})
/**
 * 全局二级索引定义
 */
@Generated(value = "Autogenerated by Thrift Compiler (0.9.2)", date = "2017-7-20")
public class GlobalSecondaryIndexSpec implements libthrift091.TBase<GlobalSecondaryIndexSpec, GlobalSecondaryIndexSpec._Fields>, java.io.Serializable, Cloneable, Comparable<GlobalSecondaryIndexSpec> {
  private static final libthrift091.protocol.TStruct STRUCT_DESC = new libthrift091.protocol.TStruct("GlobalSecondaryIndexSpec");

  private static final libthrift091.protocol.TField INDEX_ENTITY_GROUP_FIELD_DESC = new libthrift091.protocol.TField("indexEntityGroup", libthrift091.protocol.TType.STRUCT, (short)1);
  private static final libthrift091.protocol.TField INDEX_PRIMARY_KEY_FIELD_DESC = new libthrift091.protocol.TField("indexPrimaryKey", libthrift091.protocol.TType.LIST, (short)2);
  private static final libthrift091.protocol.TField PROJECTIONS_FIELD_DESC = new libthrift091.protocol.TField("projections", libthrift091.protocol.TType.LIST, (short)3);
  private static final libthrift091.protocol.TField CONSISTENCY_LEVEL_FIELD_DESC = new libthrift091.protocol.TField("consistencyLevel", libthrift091.protocol.TType.I32, (short)4);
  private static final libthrift091.protocol.TField UNIQUE_FIELD_DESC = new libthrift091.protocol.TField("unique", libthrift091.protocol.TType.BOOL, (short)5);
  private static final libthrift091.protocol.TField THROUGHPUT_FIELD_DESC = new libthrift091.protocol.TField("throughput", libthrift091.protocol.TType.STRUCT, (short)6);
  private static final libthrift091.protocol.TField SLAVE_THROUGHPUT_FIELD_DESC = new libthrift091.protocol.TField("slaveThroughput", libthrift091.protocol.TType.STRUCT, (short)7);
  private static final libthrift091.protocol.TField EXCEEDED_THROUGHPUT_FIELD_DESC = new libthrift091.protocol.TField("exceededThroughput", libthrift091.protocol.TType.STRUCT, (short)8);
  private static final libthrift091.protocol.TField EXCEEDED_SLAVE_THROUGHPUT_FIELD_DESC = new libthrift091.protocol.TField("exceededSlaveThroughput", libthrift091.protocol.TType.STRUCT, (short)9);
  private static final libthrift091.protocol.TField PRE_SPLITS_FIELD_DESC = new libthrift091.protocol.TField("preSplits", libthrift091.protocol.TType.I32, (short)10);

  private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
  static {
    schemes.put(StandardScheme.class, new GlobalSecondaryIndexSpecStandardSchemeFactory());
    schemes.put(TupleScheme.class, new GlobalSecondaryIndexSpecTupleSchemeFactory());
  }

  /**
   * 索引表的实体组键
   * 可用于对索引表进行hash
   */
  public EntityGroupSpec indexEntityGroup; // optional
  /**
   * 索引表的主键
   */
  public List<KeySpec> indexPrimaryKey; // optional
  /**
   * 投影的属性，全局二级索引不能读取非投影属性
   */
  public List<String> projections; // optional
  /**
   * 索引数据一致性级别
   * 
   * @see ConsistencyLevel
   */
  public ConsistencyLevel consistencyLevel; // optional
  /**
   * 是否为唯一索引
   */
  public boolean unique; // optional
  /**
   * 索引表的吞吐量配额
   */
  public ProvisionThroughput throughput; // optional
  /**
   * 索引表的备集群的吞吐量配额
   */
  public ProvisionThroughput slaveThroughput; // optional
  /**
   * 索引表的最大超发吞吐量配额
   */
  public ProvisionThroughput exceededThroughput; // optional
  /**
   * 索引表的备集群的最大超发吞吐量配额
   */
  public ProvisionThroughput exceededSlaveThroughput; // optional
  /**
   * 表初始分片数目，仅支持Entity Group开启hash分布的表，且仅在建表时起作用
   */
  public int preSplits; // optional

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements libthrift091.TFieldIdEnum {
    /**
     * 索引表的实体组键
     * 可用于对索引表进行hash
     */
    INDEX_ENTITY_GROUP((short)1, "indexEntityGroup"),
    /**
     * 索引表的主键
     */
    INDEX_PRIMARY_KEY((short)2, "indexPrimaryKey"),
    /**
     * 投影的属性，全局二级索引不能读取非投影属性
     */
    PROJECTIONS((short)3, "projections"),
    /**
     * 索引数据一致性级别
     * 
     * @see ConsistencyLevel
     */
    CONSISTENCY_LEVEL((short)4, "consistencyLevel"),
    /**
     * 是否为唯一索引
     */
    UNIQUE((short)5, "unique"),
    /**
     * 索引表的吞吐量配额
     */
    THROUGHPUT((short)6, "throughput"),
    /**
     * 索引表的备集群的吞吐量配额
     */
    SLAVE_THROUGHPUT((short)7, "slaveThroughput"),
    /**
     * 索引表的最大超发吞吐量配额
     */
    EXCEEDED_THROUGHPUT((short)8, "exceededThroughput"),
    /**
     * 索引表的备集群的最大超发吞吐量配额
     */
    EXCEEDED_SLAVE_THROUGHPUT((short)9, "exceededSlaveThroughput"),
    /**
     * 表初始分片数目，仅支持Entity Group开启hash分布的表，且仅在建表时起作用
     */
    PRE_SPLITS((short)10, "preSplits");

    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // INDEX_ENTITY_GROUP
          return INDEX_ENTITY_GROUP;
        case 2: // INDEX_PRIMARY_KEY
          return INDEX_PRIMARY_KEY;
        case 3: // PROJECTIONS
          return PROJECTIONS;
        case 4: // CONSISTENCY_LEVEL
          return CONSISTENCY_LEVEL;
        case 5: // UNIQUE
          return UNIQUE;
        case 6: // THROUGHPUT
          return THROUGHPUT;
        case 7: // SLAVE_THROUGHPUT
          return SLAVE_THROUGHPUT;
        case 8: // EXCEEDED_THROUGHPUT
          return EXCEEDED_THROUGHPUT;
        case 9: // EXCEEDED_SLAVE_THROUGHPUT
          return EXCEEDED_SLAVE_THROUGHPUT;
        case 10: // PRE_SPLITS
          return PRE_SPLITS;
        default:
          return null;
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }

    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }

    private final short _thriftId;
    private final String _fieldName;

    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }

    public short getThriftFieldId() {
      return _thriftId;
    }

    public String getFieldName() {
      return _fieldName;
    }
  }

  // isset id assignments
  private static final int __UNIQUE_ISSET_ID = 0;
  private static final int __PRESPLITS_ISSET_ID = 1;
  private byte __isset_bitfield = 0;
  private static final _Fields optionals[] = {_Fields.INDEX_ENTITY_GROUP,_Fields.INDEX_PRIMARY_KEY,_Fields.PROJECTIONS,_Fields.CONSISTENCY_LEVEL,_Fields.UNIQUE,_Fields.THROUGHPUT,_Fields.SLAVE_THROUGHPUT,_Fields.EXCEEDED_THROUGHPUT,_Fields.EXCEEDED_SLAVE_THROUGHPUT,_Fields.PRE_SPLITS};
  public static final Map<_Fields, libthrift091.meta_data.FieldMetaData> metaDataMap;
  static {
    Map<_Fields, libthrift091.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, libthrift091.meta_data.FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.INDEX_ENTITY_GROUP, new libthrift091.meta_data.FieldMetaData("indexEntityGroup", libthrift091.TFieldRequirementType.OPTIONAL, 
        new libthrift091.meta_data.StructMetaData(libthrift091.protocol.TType.STRUCT, EntityGroupSpec.class)));
    tmpMap.put(_Fields.INDEX_PRIMARY_KEY, new libthrift091.meta_data.FieldMetaData("indexPrimaryKey", libthrift091.TFieldRequirementType.OPTIONAL, 
        new libthrift091.meta_data.FieldValueMetaData(libthrift091.protocol.TType.LIST        , "IndexSpec")));
    tmpMap.put(_Fields.PROJECTIONS, new libthrift091.meta_data.FieldMetaData("projections", libthrift091.TFieldRequirementType.OPTIONAL, 
        new libthrift091.meta_data.FieldValueMetaData(libthrift091.protocol.TType.LIST        , "Attributes")));
    tmpMap.put(_Fields.CONSISTENCY_LEVEL, new libthrift091.meta_data.FieldMetaData("consistencyLevel", libthrift091.TFieldRequirementType.OPTIONAL, 
        new libthrift091.meta_data.EnumMetaData(libthrift091.protocol.TType.ENUM, ConsistencyLevel.class)));
    tmpMap.put(_Fields.UNIQUE, new libthrift091.meta_data.FieldMetaData("unique", libthrift091.TFieldRequirementType.OPTIONAL, 
        new libthrift091.meta_data.FieldValueMetaData(libthrift091.protocol.TType.BOOL)));
    tmpMap.put(_Fields.THROUGHPUT, new libthrift091.meta_data.FieldMetaData("throughput", libthrift091.TFieldRequirementType.OPTIONAL, 
        new libthrift091.meta_data.StructMetaData(libthrift091.protocol.TType.STRUCT, ProvisionThroughput.class)));
    tmpMap.put(_Fields.SLAVE_THROUGHPUT, new libthrift091.meta_data.FieldMetaData("slaveThroughput", libthrift091.TFieldRequirementType.OPTIONAL, 
        new libthrift091.meta_data.StructMetaData(libthrift091.protocol.TType.STRUCT, ProvisionThroughput.class)));
    tmpMap.put(_Fields.EXCEEDED_THROUGHPUT, new libthrift091.meta_data.FieldMetaData("exceededThroughput", libthrift091.TFieldRequirementType.OPTIONAL, 
        new libthrift091.meta_data.StructMetaData(libthrift091.protocol.TType.STRUCT, ProvisionThroughput.class)));
    tmpMap.put(_Fields.EXCEEDED_SLAVE_THROUGHPUT, new libthrift091.meta_data.FieldMetaData("exceededSlaveThroughput", libthrift091.TFieldRequirementType.OPTIONAL, 
        new libthrift091.meta_data.StructMetaData(libthrift091.protocol.TType.STRUCT, ProvisionThroughput.class)));
    tmpMap.put(_Fields.PRE_SPLITS, new libthrift091.meta_data.FieldMetaData("preSplits", libthrift091.TFieldRequirementType.OPTIONAL, 
        new libthrift091.meta_data.FieldValueMetaData(libthrift091.protocol.TType.I32)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    libthrift091.meta_data.FieldMetaData.addStructMetaDataMap(GlobalSecondaryIndexSpec.class, metaDataMap);
  }

  public GlobalSecondaryIndexSpec() {
    this.consistencyLevel = com.xiaomi.infra.galaxy.sds.thrift.ConsistencyLevel.STRONG;

    this.unique = false;

    this.preSplits = 1;

  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public GlobalSecondaryIndexSpec(GlobalSecondaryIndexSpec other) {
    __isset_bitfield = other.__isset_bitfield;
    if (other.isSetIndexEntityGroup()) {
      this.indexEntityGroup = new EntityGroupSpec(other.indexEntityGroup);
    }
    if (other.isSetIndexPrimaryKey()) {
      this.indexPrimaryKey = other.indexPrimaryKey;
    }
    if (other.isSetProjections()) {
      this.projections = other.projections;
    }
    if (other.isSetConsistencyLevel()) {
      this.consistencyLevel = other.consistencyLevel;
    }
    this.unique = other.unique;
    if (other.isSetThroughput()) {
      this.throughput = new ProvisionThroughput(other.throughput);
    }
    if (other.isSetSlaveThroughput()) {
      this.slaveThroughput = new ProvisionThroughput(other.slaveThroughput);
    }
    if (other.isSetExceededThroughput()) {
      this.exceededThroughput = new ProvisionThroughput(other.exceededThroughput);
    }
    if (other.isSetExceededSlaveThroughput()) {
      this.exceededSlaveThroughput = new ProvisionThroughput(other.exceededSlaveThroughput);
    }
    this.preSplits = other.preSplits;
  }

  public GlobalSecondaryIndexSpec deepCopy() {
    return new GlobalSecondaryIndexSpec(this);
  }

  @Override
  public void clear() {
    this.indexEntityGroup = null;
    this.indexPrimaryKey = null;
    this.projections = null;
    this.consistencyLevel = com.xiaomi.infra.galaxy.sds.thrift.ConsistencyLevel.STRONG;

    this.unique = false;

    this.throughput = null;
    this.slaveThroughput = null;
    this.exceededThroughput = null;
    this.exceededSlaveThroughput = null;
    this.preSplits = 1;

  }

  /**
   * 索引表的实体组键
   * 可用于对索引表进行hash
   */
  public EntityGroupSpec getIndexEntityGroup() {
    return this.indexEntityGroup;
  }

  /**
   * 索引表的实体组键
   * 可用于对索引表进行hash
   */
  public GlobalSecondaryIndexSpec setIndexEntityGroup(EntityGroupSpec indexEntityGroup) {
    this.indexEntityGroup = indexEntityGroup;
    return this;
  }

  public void unsetIndexEntityGroup() {
    this.indexEntityGroup = null;
  }

  /** Returns true if field indexEntityGroup is set (has been assigned a value) and false otherwise */
  public boolean isSetIndexEntityGroup() {
    return this.indexEntityGroup != null;
  }

  public void setIndexEntityGroupIsSet(boolean value) {
    if (!value) {
      this.indexEntityGroup = null;
    }
  }

  public int getIndexPrimaryKeySize() {
    return (this.indexPrimaryKey == null) ? 0 : this.indexPrimaryKey.size();
  }

  public java.util.Iterator<KeySpec> getIndexPrimaryKeyIterator() {
    return (this.indexPrimaryKey == null) ? null : this.indexPrimaryKey.iterator();
  }

  public void addToIndexPrimaryKey(KeySpec elem) {
    if (this.indexPrimaryKey == null) {
      this.indexPrimaryKey = new ArrayList<KeySpec>();
    }
    this.indexPrimaryKey.add(elem);
  }

  /**
   * 索引表的主键
   */
  public List<KeySpec> getIndexPrimaryKey() {
    return this.indexPrimaryKey;
  }

  /**
   * 索引表的主键
   */
  public GlobalSecondaryIndexSpec setIndexPrimaryKey(List<KeySpec> indexPrimaryKey) {
    this.indexPrimaryKey = indexPrimaryKey;
    return this;
  }

  public void unsetIndexPrimaryKey() {
    this.indexPrimaryKey = null;
  }

  /** Returns true if field indexPrimaryKey is set (has been assigned a value) and false otherwise */
  public boolean isSetIndexPrimaryKey() {
    return this.indexPrimaryKey != null;
  }

  public void setIndexPrimaryKeyIsSet(boolean value) {
    if (!value) {
      this.indexPrimaryKey = null;
    }
  }

  public int getProjectionsSize() {
    return (this.projections == null) ? 0 : this.projections.size();
  }

  public java.util.Iterator<String> getProjectionsIterator() {
    return (this.projections == null) ? null : this.projections.iterator();
  }

  public void addToProjections(String elem) {
    if (this.projections == null) {
      this.projections = new ArrayList<String>();
    }
    this.projections.add(elem);
  }

  /**
   * 投影的属性，全局二级索引不能读取非投影属性
   */
  public List<String> getProjections() {
    return this.projections;
  }

  /**
   * 投影的属性，全局二级索引不能读取非投影属性
   */
  public GlobalSecondaryIndexSpec setProjections(List<String> projections) {
    this.projections = projections;
    return this;
  }

  public void unsetProjections() {
    this.projections = null;
  }

  /** Returns true if field projections is set (has been assigned a value) and false otherwise */
  public boolean isSetProjections() {
    return this.projections != null;
  }

  public void setProjectionsIsSet(boolean value) {
    if (!value) {
      this.projections = null;
    }
  }

  /**
   * 索引数据一致性级别
   * 
   * @see ConsistencyLevel
   */
  public ConsistencyLevel getConsistencyLevel() {
    return this.consistencyLevel;
  }

  /**
   * 索引数据一致性级别
   * 
   * @see ConsistencyLevel
   */
  public GlobalSecondaryIndexSpec setConsistencyLevel(ConsistencyLevel consistencyLevel) {
    this.consistencyLevel = consistencyLevel;
    return this;
  }

  public void unsetConsistencyLevel() {
    this.consistencyLevel = null;
  }

  /** Returns true if field consistencyLevel is set (has been assigned a value) and false otherwise */
  public boolean isSetConsistencyLevel() {
    return this.consistencyLevel != null;
  }

  public void setConsistencyLevelIsSet(boolean value) {
    if (!value) {
      this.consistencyLevel = null;
    }
  }

  /**
   * 是否为唯一索引
   */
  public boolean isUnique() {
    return this.unique;
  }

  /**
   * 是否为唯一索引
   */
  public GlobalSecondaryIndexSpec setUnique(boolean unique) {
    this.unique = unique;
    setUniqueIsSet(true);
    return this;
  }

  public void unsetUnique() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __UNIQUE_ISSET_ID);
  }

  /** Returns true if field unique is set (has been assigned a value) and false otherwise */
  public boolean isSetUnique() {
    return EncodingUtils.testBit(__isset_bitfield, __UNIQUE_ISSET_ID);
  }

  public void setUniqueIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __UNIQUE_ISSET_ID, value);
  }

  /**
   * 索引表的吞吐量配额
   */
  public ProvisionThroughput getThroughput() {
    return this.throughput;
  }

  /**
   * 索引表的吞吐量配额
   */
  public GlobalSecondaryIndexSpec setThroughput(ProvisionThroughput throughput) {
    this.throughput = throughput;
    return this;
  }

  public void unsetThroughput() {
    this.throughput = null;
  }

  /** Returns true if field throughput is set (has been assigned a value) and false otherwise */
  public boolean isSetThroughput() {
    return this.throughput != null;
  }

  public void setThroughputIsSet(boolean value) {
    if (!value) {
      this.throughput = null;
    }
  }

  /**
   * 索引表的备集群的吞吐量配额
   */
  public ProvisionThroughput getSlaveThroughput() {
    return this.slaveThroughput;
  }

  /**
   * 索引表的备集群的吞吐量配额
   */
  public GlobalSecondaryIndexSpec setSlaveThroughput(ProvisionThroughput slaveThroughput) {
    this.slaveThroughput = slaveThroughput;
    return this;
  }

  public void unsetSlaveThroughput() {
    this.slaveThroughput = null;
  }

  /** Returns true if field slaveThroughput is set (has been assigned a value) and false otherwise */
  public boolean isSetSlaveThroughput() {
    return this.slaveThroughput != null;
  }

  public void setSlaveThroughputIsSet(boolean value) {
    if (!value) {
      this.slaveThroughput = null;
    }
  }

  /**
   * 索引表的最大超发吞吐量配额
   */
  public ProvisionThroughput getExceededThroughput() {
    return this.exceededThroughput;
  }

  /**
   * 索引表的最大超发吞吐量配额
   */
  public GlobalSecondaryIndexSpec setExceededThroughput(ProvisionThroughput exceededThroughput) {
    this.exceededThroughput = exceededThroughput;
    return this;
  }

  public void unsetExceededThroughput() {
    this.exceededThroughput = null;
  }

  /** Returns true if field exceededThroughput is set (has been assigned a value) and false otherwise */
  public boolean isSetExceededThroughput() {
    return this.exceededThroughput != null;
  }

  public void setExceededThroughputIsSet(boolean value) {
    if (!value) {
      this.exceededThroughput = null;
    }
  }

  /**
   * 索引表的备集群的最大超发吞吐量配额
   */
  public ProvisionThroughput getExceededSlaveThroughput() {
    return this.exceededSlaveThroughput;
  }

  /**
   * 索引表的备集群的最大超发吞吐量配额
   */
  public GlobalSecondaryIndexSpec setExceededSlaveThroughput(ProvisionThroughput exceededSlaveThroughput) {
    this.exceededSlaveThroughput = exceededSlaveThroughput;
    return this;
  }

  public void unsetExceededSlaveThroughput() {
    this.exceededSlaveThroughput = null;
  }

  /** Returns true if field exceededSlaveThroughput is set (has been assigned a value) and false otherwise */
  public boolean isSetExceededSlaveThroughput() {
    return this.exceededSlaveThroughput != null;
  }

  public void setExceededSlaveThroughputIsSet(boolean value) {
    if (!value) {
      this.exceededSlaveThroughput = null;
    }
  }

  /**
   * 表初始分片数目，仅支持Entity Group开启hash分布的表，且仅在建表时起作用
   */
  public int getPreSplits() {
    return this.preSplits;
  }

  /**
   * 表初始分片数目，仅支持Entity Group开启hash分布的表，且仅在建表时起作用
   */
  public GlobalSecondaryIndexSpec setPreSplits(int preSplits) {
    this.preSplits = preSplits;
    setPreSplitsIsSet(true);
    return this;
  }

  public void unsetPreSplits() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __PRESPLITS_ISSET_ID);
  }

  /** Returns true if field preSplits is set (has been assigned a value) and false otherwise */
  public boolean isSetPreSplits() {
    return EncodingUtils.testBit(__isset_bitfield, __PRESPLITS_ISSET_ID);
  }

  public void setPreSplitsIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __PRESPLITS_ISSET_ID, value);
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case INDEX_ENTITY_GROUP:
      if (value == null) {
        unsetIndexEntityGroup();
      } else {
        setIndexEntityGroup((EntityGroupSpec)value);
      }
      break;

    case INDEX_PRIMARY_KEY:
      if (value == null) {
        unsetIndexPrimaryKey();
      } else {
        setIndexPrimaryKey((List<KeySpec>)value);
      }
      break;

    case PROJECTIONS:
      if (value == null) {
        unsetProjections();
      } else {
        setProjections((List<String>)value);
      }
      break;

    case CONSISTENCY_LEVEL:
      if (value == null) {
        unsetConsistencyLevel();
      } else {
        setConsistencyLevel((ConsistencyLevel)value);
      }
      break;

    case UNIQUE:
      if (value == null) {
        unsetUnique();
      } else {
        setUnique((Boolean)value);
      }
      break;

    case THROUGHPUT:
      if (value == null) {
        unsetThroughput();
      } else {
        setThroughput((ProvisionThroughput)value);
      }
      break;

    case SLAVE_THROUGHPUT:
      if (value == null) {
        unsetSlaveThroughput();
      } else {
        setSlaveThroughput((ProvisionThroughput)value);
      }
      break;

    case EXCEEDED_THROUGHPUT:
      if (value == null) {
        unsetExceededThroughput();
      } else {
        setExceededThroughput((ProvisionThroughput)value);
      }
      break;

    case EXCEEDED_SLAVE_THROUGHPUT:
      if (value == null) {
        unsetExceededSlaveThroughput();
      } else {
        setExceededSlaveThroughput((ProvisionThroughput)value);
      }
      break;

    case PRE_SPLITS:
      if (value == null) {
        unsetPreSplits();
      } else {
        setPreSplits((Integer)value);
      }
      break;

    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case INDEX_ENTITY_GROUP:
      return getIndexEntityGroup();

    case INDEX_PRIMARY_KEY:
      return getIndexPrimaryKey();

    case PROJECTIONS:
      return getProjections();

    case CONSISTENCY_LEVEL:
      return getConsistencyLevel();

    case UNIQUE:
      return Boolean.valueOf(isUnique());

    case THROUGHPUT:
      return getThroughput();

    case SLAVE_THROUGHPUT:
      return getSlaveThroughput();

    case EXCEEDED_THROUGHPUT:
      return getExceededThroughput();

    case EXCEEDED_SLAVE_THROUGHPUT:
      return getExceededSlaveThroughput();

    case PRE_SPLITS:
      return Integer.valueOf(getPreSplits());

    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case INDEX_ENTITY_GROUP:
      return isSetIndexEntityGroup();
    case INDEX_PRIMARY_KEY:
      return isSetIndexPrimaryKey();
    case PROJECTIONS:
      return isSetProjections();
    case CONSISTENCY_LEVEL:
      return isSetConsistencyLevel();
    case UNIQUE:
      return isSetUnique();
    case THROUGHPUT:
      return isSetThroughput();
    case SLAVE_THROUGHPUT:
      return isSetSlaveThroughput();
    case EXCEEDED_THROUGHPUT:
      return isSetExceededThroughput();
    case EXCEEDED_SLAVE_THROUGHPUT:
      return isSetExceededSlaveThroughput();
    case PRE_SPLITS:
      return isSetPreSplits();
    }
    throw new IllegalStateException();
  }

  @Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof GlobalSecondaryIndexSpec)
      return this.equals((GlobalSecondaryIndexSpec)that);
    return false;
  }

  public boolean equals(GlobalSecondaryIndexSpec that) {
    if (that == null)
      return false;

    boolean this_present_indexEntityGroup = true && this.isSetIndexEntityGroup();
    boolean that_present_indexEntityGroup = true && that.isSetIndexEntityGroup();
    if (this_present_indexEntityGroup || that_present_indexEntityGroup) {
      if (!(this_present_indexEntityGroup && that_present_indexEntityGroup))
        return false;
      if (!this.indexEntityGroup.equals(that.indexEntityGroup))
        return false;
    }

    boolean this_present_indexPrimaryKey = true && this.isSetIndexPrimaryKey();
    boolean that_present_indexPrimaryKey = true && that.isSetIndexPrimaryKey();
    if (this_present_indexPrimaryKey || that_present_indexPrimaryKey) {
      if (!(this_present_indexPrimaryKey && that_present_indexPrimaryKey))
        return false;
      if (!this.indexPrimaryKey.equals(that.indexPrimaryKey))
        return false;
    }

    boolean this_present_projections = true && this.isSetProjections();
    boolean that_present_projections = true && that.isSetProjections();
    if (this_present_projections || that_present_projections) {
      if (!(this_present_projections && that_present_projections))
        return false;
      if (!this.projections.equals(that.projections))
        return false;
    }

    boolean this_present_consistencyLevel = true && this.isSetConsistencyLevel();
    boolean that_present_consistencyLevel = true && that.isSetConsistencyLevel();
    if (this_present_consistencyLevel || that_present_consistencyLevel) {
      if (!(this_present_consistencyLevel && that_present_consistencyLevel))
        return false;
      if (!this.consistencyLevel.equals(that.consistencyLevel))
        return false;
    }

    boolean this_present_unique = true && this.isSetUnique();
    boolean that_present_unique = true && that.isSetUnique();
    if (this_present_unique || that_present_unique) {
      if (!(this_present_unique && that_present_unique))
        return false;
      if (this.unique != that.unique)
        return false;
    }

    boolean this_present_throughput = true && this.isSetThroughput();
    boolean that_present_throughput = true && that.isSetThroughput();
    if (this_present_throughput || that_present_throughput) {
      if (!(this_present_throughput && that_present_throughput))
        return false;
      if (!this.throughput.equals(that.throughput))
        return false;
    }

    boolean this_present_slaveThroughput = true && this.isSetSlaveThroughput();
    boolean that_present_slaveThroughput = true && that.isSetSlaveThroughput();
    if (this_present_slaveThroughput || that_present_slaveThroughput) {
      if (!(this_present_slaveThroughput && that_present_slaveThroughput))
        return false;
      if (!this.slaveThroughput.equals(that.slaveThroughput))
        return false;
    }

    boolean this_present_exceededThroughput = true && this.isSetExceededThroughput();
    boolean that_present_exceededThroughput = true && that.isSetExceededThroughput();
    if (this_present_exceededThroughput || that_present_exceededThroughput) {
      if (!(this_present_exceededThroughput && that_present_exceededThroughput))
        return false;
      if (!this.exceededThroughput.equals(that.exceededThroughput))
        return false;
    }

    boolean this_present_exceededSlaveThroughput = true && this.isSetExceededSlaveThroughput();
    boolean that_present_exceededSlaveThroughput = true && that.isSetExceededSlaveThroughput();
    if (this_present_exceededSlaveThroughput || that_present_exceededSlaveThroughput) {
      if (!(this_present_exceededSlaveThroughput && that_present_exceededSlaveThroughput))
        return false;
      if (!this.exceededSlaveThroughput.equals(that.exceededSlaveThroughput))
        return false;
    }

    boolean this_present_preSplits = true && this.isSetPreSplits();
    boolean that_present_preSplits = true && that.isSetPreSplits();
    if (this_present_preSplits || that_present_preSplits) {
      if (!(this_present_preSplits && that_present_preSplits))
        return false;
      if (this.preSplits != that.preSplits)
        return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    List<Object> list = new ArrayList<Object>();

    boolean present_indexEntityGroup = true && (isSetIndexEntityGroup());
    list.add(present_indexEntityGroup);
    if (present_indexEntityGroup)
      list.add(indexEntityGroup);

    boolean present_indexPrimaryKey = true && (isSetIndexPrimaryKey());
    list.add(present_indexPrimaryKey);
    if (present_indexPrimaryKey)
      list.add(indexPrimaryKey);

    boolean present_projections = true && (isSetProjections());
    list.add(present_projections);
    if (present_projections)
      list.add(projections);

    boolean present_consistencyLevel = true && (isSetConsistencyLevel());
    list.add(present_consistencyLevel);
    if (present_consistencyLevel)
      list.add(consistencyLevel.getValue());

    boolean present_unique = true && (isSetUnique());
    list.add(present_unique);
    if (present_unique)
      list.add(unique);

    boolean present_throughput = true && (isSetThroughput());
    list.add(present_throughput);
    if (present_throughput)
      list.add(throughput);

    boolean present_slaveThroughput = true && (isSetSlaveThroughput());
    list.add(present_slaveThroughput);
    if (present_slaveThroughput)
      list.add(slaveThroughput);

    boolean present_exceededThroughput = true && (isSetExceededThroughput());
    list.add(present_exceededThroughput);
    if (present_exceededThroughput)
      list.add(exceededThroughput);

    boolean present_exceededSlaveThroughput = true && (isSetExceededSlaveThroughput());
    list.add(present_exceededSlaveThroughput);
    if (present_exceededSlaveThroughput)
      list.add(exceededSlaveThroughput);

    boolean present_preSplits = true && (isSetPreSplits());
    list.add(present_preSplits);
    if (present_preSplits)
      list.add(preSplits);

    return list.hashCode();
  }

  @Override
  public int compareTo(GlobalSecondaryIndexSpec other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;

    lastComparison = Boolean.valueOf(isSetIndexEntityGroup()).compareTo(other.isSetIndexEntityGroup());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetIndexEntityGroup()) {
      lastComparison = libthrift091.TBaseHelper.compareTo(this.indexEntityGroup, other.indexEntityGroup);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetIndexPrimaryKey()).compareTo(other.isSetIndexPrimaryKey());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetIndexPrimaryKey()) {
      lastComparison = libthrift091.TBaseHelper.compareTo(this.indexPrimaryKey, other.indexPrimaryKey);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetProjections()).compareTo(other.isSetProjections());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetProjections()) {
      lastComparison = libthrift091.TBaseHelper.compareTo(this.projections, other.projections);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetConsistencyLevel()).compareTo(other.isSetConsistencyLevel());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetConsistencyLevel()) {
      lastComparison = libthrift091.TBaseHelper.compareTo(this.consistencyLevel, other.consistencyLevel);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetUnique()).compareTo(other.isSetUnique());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetUnique()) {
      lastComparison = libthrift091.TBaseHelper.compareTo(this.unique, other.unique);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetThroughput()).compareTo(other.isSetThroughput());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetThroughput()) {
      lastComparison = libthrift091.TBaseHelper.compareTo(this.throughput, other.throughput);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetSlaveThroughput()).compareTo(other.isSetSlaveThroughput());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetSlaveThroughput()) {
      lastComparison = libthrift091.TBaseHelper.compareTo(this.slaveThroughput, other.slaveThroughput);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetExceededThroughput()).compareTo(other.isSetExceededThroughput());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetExceededThroughput()) {
      lastComparison = libthrift091.TBaseHelper.compareTo(this.exceededThroughput, other.exceededThroughput);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetExceededSlaveThroughput()).compareTo(other.isSetExceededSlaveThroughput());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetExceededSlaveThroughput()) {
      lastComparison = libthrift091.TBaseHelper.compareTo(this.exceededSlaveThroughput, other.exceededSlaveThroughput);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetPreSplits()).compareTo(other.isSetPreSplits());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetPreSplits()) {
      lastComparison = libthrift091.TBaseHelper.compareTo(this.preSplits, other.preSplits);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }

  public void read(libthrift091.protocol.TProtocol iprot) throws libthrift091.TException {
    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
  }

  public void write(libthrift091.protocol.TProtocol oprot) throws libthrift091.TException {
    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder("GlobalSecondaryIndexSpec(");
    boolean first = true;

    if (isSetIndexEntityGroup()) {
      sb.append("indexEntityGroup:");
      if (this.indexEntityGroup == null) {
        sb.append("null");
      } else {
        sb.append(this.indexEntityGroup);
      }
      first = false;
    }
    if (isSetIndexPrimaryKey()) {
      if (!first) sb.append(", ");
      sb.append("indexPrimaryKey:");
      if (this.indexPrimaryKey == null) {
        sb.append("null");
      } else {
        sb.append(this.indexPrimaryKey);
      }
      first = false;
    }
    if (isSetProjections()) {
      if (!first) sb.append(", ");
      sb.append("projections:");
      if (this.projections == null) {
        sb.append("null");
      } else {
        sb.append(this.projections);
      }
      first = false;
    }
    if (isSetConsistencyLevel()) {
      if (!first) sb.append(", ");
      sb.append("consistencyLevel:");
      if (this.consistencyLevel == null) {
        sb.append("null");
      } else {
        sb.append(this.consistencyLevel);
      }
      first = false;
    }
    if (isSetUnique()) {
      if (!first) sb.append(", ");
      sb.append("unique:");
      sb.append(this.unique);
      first = false;
    }
    if (isSetThroughput()) {
      if (!first) sb.append(", ");
      sb.append("throughput:");
      if (this.throughput == null) {
        sb.append("null");
      } else {
        sb.append(this.throughput);
      }
      first = false;
    }
    if (isSetSlaveThroughput()) {
      if (!first) sb.append(", ");
      sb.append("slaveThroughput:");
      if (this.slaveThroughput == null) {
        sb.append("null");
      } else {
        sb.append(this.slaveThroughput);
      }
      first = false;
    }
    if (isSetExceededThroughput()) {
      if (!first) sb.append(", ");
      sb.append("exceededThroughput:");
      if (this.exceededThroughput == null) {
        sb.append("null");
      } else {
        sb.append(this.exceededThroughput);
      }
      first = false;
    }
    if (isSetExceededSlaveThroughput()) {
      if (!first) sb.append(", ");
      sb.append("exceededSlaveThroughput:");
      if (this.exceededSlaveThroughput == null) {
        sb.append("null");
      } else {
        sb.append(this.exceededSlaveThroughput);
      }
      first = false;
    }
    if (isSetPreSplits()) {
      if (!first) sb.append(", ");
      sb.append("preSplits:");
      sb.append(this.preSplits);
      first = false;
    }
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws libthrift091.TException {
    // check for required fields
    // check for sub-struct validity
    if (indexEntityGroup != null) {
      indexEntityGroup.validate();
    }
    if (throughput != null) {
      throughput.validate();
    }
    if (slaveThroughput != null) {
      slaveThroughput.validate();
    }
    if (exceededThroughput != null) {
      exceededThroughput.validate();
    }
    if (exceededSlaveThroughput != null) {
      exceededSlaveThroughput.validate();
    }
  }

  private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
    try {
      write(new libthrift091.protocol.TCompactProtocol(new libthrift091.transport.TIOStreamTransport(out)));
    } catch (libthrift091.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
    try {
      // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
      __isset_bitfield = 0;
      read(new libthrift091.protocol.TCompactProtocol(new libthrift091.transport.TIOStreamTransport(in)));
    } catch (libthrift091.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private static class GlobalSecondaryIndexSpecStandardSchemeFactory implements SchemeFactory {
    public GlobalSecondaryIndexSpecStandardScheme getScheme() {
      return new GlobalSecondaryIndexSpecStandardScheme();
    }
  }

  private static class GlobalSecondaryIndexSpecStandardScheme extends StandardScheme<GlobalSecondaryIndexSpec> {

    public void read(libthrift091.protocol.TProtocol iprot, GlobalSecondaryIndexSpec struct) throws libthrift091.TException {
      libthrift091.protocol.TField schemeField;
      iprot.readStructBegin();
      while (true)
      {
        schemeField = iprot.readFieldBegin();
        if (schemeField.type == libthrift091.protocol.TType.STOP) { 
          break;
        }
        switch (schemeField.id) {
          case 1: // INDEX_ENTITY_GROUP
            if (schemeField.type == libthrift091.protocol.TType.STRUCT) {
              struct.indexEntityGroup = new EntityGroupSpec();
              struct.indexEntityGroup.read(iprot);
              struct.setIndexEntityGroupIsSet(true);
            } else { 
              libthrift091.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 2: // INDEX_PRIMARY_KEY
            if (schemeField.type == libthrift091.protocol.TType.LIST) {
              {
                libthrift091.protocol.TList _list88 = iprot.readListBegin();
                struct.indexPrimaryKey = new ArrayList<KeySpec>(_list88.size);
                KeySpec _elem89;
                for (int _i90 = 0; _i90 < _list88.size; ++_i90)
                {
                  _elem89 = new KeySpec();
                  _elem89.read(iprot);
                  struct.indexPrimaryKey.add(_elem89);
                }
                iprot.readListEnd();
              }
              struct.setIndexPrimaryKeyIsSet(true);
            } else { 
              libthrift091.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 3: // PROJECTIONS
            if (schemeField.type == libthrift091.protocol.TType.LIST) {
              {
                libthrift091.protocol.TList _list91 = iprot.readListBegin();
                struct.projections = new ArrayList<String>(_list91.size);
                String _elem92;
                for (int _i93 = 0; _i93 < _list91.size; ++_i93)
                {
                  _elem92 = iprot.readString();
                  struct.projections.add(_elem92);
                }
                iprot.readListEnd();
              }
              struct.setProjectionsIsSet(true);
            } else { 
              libthrift091.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 4: // CONSISTENCY_LEVEL
            if (schemeField.type == libthrift091.protocol.TType.I32) {
              struct.consistencyLevel = com.xiaomi.infra.galaxy.sds.thrift.ConsistencyLevel.findByValue(iprot.readI32());
              struct.setConsistencyLevelIsSet(true);
            } else { 
              libthrift091.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 5: // UNIQUE
            if (schemeField.type == libthrift091.protocol.TType.BOOL) {
              struct.unique = iprot.readBool();
              struct.setUniqueIsSet(true);
            } else { 
              libthrift091.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 6: // THROUGHPUT
            if (schemeField.type == libthrift091.protocol.TType.STRUCT) {
              struct.throughput = new ProvisionThroughput();
              struct.throughput.read(iprot);
              struct.setThroughputIsSet(true);
            } else { 
              libthrift091.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 7: // SLAVE_THROUGHPUT
            if (schemeField.type == libthrift091.protocol.TType.STRUCT) {
              struct.slaveThroughput = new ProvisionThroughput();
              struct.slaveThroughput.read(iprot);
              struct.setSlaveThroughputIsSet(true);
            } else { 
              libthrift091.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 8: // EXCEEDED_THROUGHPUT
            if (schemeField.type == libthrift091.protocol.TType.STRUCT) {
              struct.exceededThroughput = new ProvisionThroughput();
              struct.exceededThroughput.read(iprot);
              struct.setExceededThroughputIsSet(true);
            } else { 
              libthrift091.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 9: // EXCEEDED_SLAVE_THROUGHPUT
            if (schemeField.type == libthrift091.protocol.TType.STRUCT) {
              struct.exceededSlaveThroughput = new ProvisionThroughput();
              struct.exceededSlaveThroughput.read(iprot);
              struct.setExceededSlaveThroughputIsSet(true);
            } else { 
              libthrift091.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 10: // PRE_SPLITS
            if (schemeField.type == libthrift091.protocol.TType.I32) {
              struct.preSplits = iprot.readI32();
              struct.setPreSplitsIsSet(true);
            } else { 
              libthrift091.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          default:
            libthrift091.protocol.TProtocolUtil.skip(iprot, schemeField.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      struct.validate();
    }

    public void write(libthrift091.protocol.TProtocol oprot, GlobalSecondaryIndexSpec struct) throws libthrift091.TException {
      struct.validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (struct.indexEntityGroup != null) {
        if (struct.isSetIndexEntityGroup()) {
          oprot.writeFieldBegin(INDEX_ENTITY_GROUP_FIELD_DESC);
          struct.indexEntityGroup.write(oprot);
          oprot.writeFieldEnd();
        }
      }
      if (struct.indexPrimaryKey != null) {
        if (struct.isSetIndexPrimaryKey()) {
          oprot.writeFieldBegin(INDEX_PRIMARY_KEY_FIELD_DESC);
          {
            oprot.writeListBegin(new libthrift091.protocol.TList(libthrift091.protocol.TType.STRUCT, struct.indexPrimaryKey.size()));
            for (KeySpec _iter94 : struct.indexPrimaryKey)
            {
              _iter94.write(oprot);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
      }
      if (struct.projections != null) {
        if (struct.isSetProjections()) {
          oprot.writeFieldBegin(PROJECTIONS_FIELD_DESC);
          {
            oprot.writeListBegin(new libthrift091.protocol.TList(libthrift091.protocol.TType.STRING, struct.projections.size()));
            for (String _iter95 : struct.projections)
            {
              oprot.writeString(_iter95);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
      }
      if (struct.consistencyLevel != null) {
        if (struct.isSetConsistencyLevel()) {
          oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
          oprot.writeI32(struct.consistencyLevel.getValue());
          oprot.writeFieldEnd();
        }
      }
      if (struct.isSetUnique()) {
        oprot.writeFieldBegin(UNIQUE_FIELD_DESC);
        oprot.writeBool(struct.unique);
        oprot.writeFieldEnd();
      }
      if (struct.throughput != null) {
        if (struct.isSetThroughput()) {
          oprot.writeFieldBegin(THROUGHPUT_FIELD_DESC);
          struct.throughput.write(oprot);
          oprot.writeFieldEnd();
        }
      }
      if (struct.slaveThroughput != null) {
        if (struct.isSetSlaveThroughput()) {
          oprot.writeFieldBegin(SLAVE_THROUGHPUT_FIELD_DESC);
          struct.slaveThroughput.write(oprot);
          oprot.writeFieldEnd();
        }
      }
      if (struct.exceededThroughput != null) {
        if (struct.isSetExceededThroughput()) {
          oprot.writeFieldBegin(EXCEEDED_THROUGHPUT_FIELD_DESC);
          struct.exceededThroughput.write(oprot);
          oprot.writeFieldEnd();
        }
      }
      if (struct.exceededSlaveThroughput != null) {
        if (struct.isSetExceededSlaveThroughput()) {
          oprot.writeFieldBegin(EXCEEDED_SLAVE_THROUGHPUT_FIELD_DESC);
          struct.exceededSlaveThroughput.write(oprot);
          oprot.writeFieldEnd();
        }
      }
      if (struct.isSetPreSplits()) {
        oprot.writeFieldBegin(PRE_SPLITS_FIELD_DESC);
        oprot.writeI32(struct.preSplits);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

  }

  private static class GlobalSecondaryIndexSpecTupleSchemeFactory implements SchemeFactory {
    public GlobalSecondaryIndexSpecTupleScheme getScheme() {
      return new GlobalSecondaryIndexSpecTupleScheme();
    }
  }

  private static class GlobalSecondaryIndexSpecTupleScheme extends TupleScheme<GlobalSecondaryIndexSpec> {

    @Override
    public void write(libthrift091.protocol.TProtocol prot, GlobalSecondaryIndexSpec struct) throws libthrift091.TException {
      TTupleProtocol oprot = (TTupleProtocol) prot;
      BitSet optionals = new BitSet();
      if (struct.isSetIndexEntityGroup()) {
        optionals.set(0);
      }
      if (struct.isSetIndexPrimaryKey()) {
        optionals.set(1);
      }
      if (struct.isSetProjections()) {
        optionals.set(2);
      }
      if (struct.isSetConsistencyLevel()) {
        optionals.set(3);
      }
      if (struct.isSetUnique()) {
        optionals.set(4);
      }
      if (struct.isSetThroughput()) {
        optionals.set(5);
      }
      if (struct.isSetSlaveThroughput()) {
        optionals.set(6);
      }
      if (struct.isSetExceededThroughput()) {
        optionals.set(7);
      }
      if (struct.isSetExceededSlaveThroughput()) {
        optionals.set(8);
      }
      if (struct.isSetPreSplits()) {
        optionals.set(9);
      }
      oprot.writeBitSet(optionals, 10);
      if (struct.isSetIndexEntityGroup()) {
        struct.indexEntityGroup.write(oprot);
      }
      if (struct.isSetIndexPrimaryKey()) {
        {
          oprot.writeI32(struct.indexPrimaryKey.size());
          for (KeySpec _iter96 : struct.indexPrimaryKey)
          {
            _iter96.write(oprot);
          }
        }
      }
      if (struct.isSetProjections()) {
        {
          oprot.writeI32(struct.projections.size());
          for (String _iter97 : struct.projections)
          {
            oprot.writeString(_iter97);
          }
        }
      }
      if (struct.isSetConsistencyLevel()) {
        oprot.writeI32(struct.consistencyLevel.getValue());
      }
      if (struct.isSetUnique()) {
        oprot.writeBool(struct.unique);
      }
      if (struct.isSetThroughput()) {
        struct.throughput.write(oprot);
      }
      if (struct.isSetSlaveThroughput()) {
        struct.slaveThroughput.write(oprot);
      }
      if (struct.isSetExceededThroughput()) {
        struct.exceededThroughput.write(oprot);
      }
      if (struct.isSetExceededSlaveThroughput()) {
        struct.exceededSlaveThroughput.write(oprot);
      }
      if (struct.isSetPreSplits()) {
        oprot.writeI32(struct.preSplits);
      }
    }

    @Override
    public void read(libthrift091.protocol.TProtocol prot, GlobalSecondaryIndexSpec struct) throws libthrift091.TException {
      TTupleProtocol iprot = (TTupleProtocol) prot;
      BitSet incoming = iprot.readBitSet(10);
      if (incoming.get(0)) {
        struct.indexEntityGroup = new EntityGroupSpec();
        struct.indexEntityGroup.read(iprot);
        struct.setIndexEntityGroupIsSet(true);
      }
      if (incoming.get(1)) {
        {
          libthrift091.protocol.TList _list98 = new libthrift091.protocol.TList(libthrift091.protocol.TType.STRUCT, iprot.readI32());
          struct.indexPrimaryKey = new ArrayList<KeySpec>(_list98.size);
          KeySpec _elem99;
          for (int _i100 = 0; _i100 < _list98.size; ++_i100)
          {
            _elem99 = new KeySpec();
            _elem99.read(iprot);
            struct.indexPrimaryKey.add(_elem99);
          }
        }
        struct.setIndexPrimaryKeyIsSet(true);
      }
      if (incoming.get(2)) {
        {
          libthrift091.protocol.TList _list101 = new libthrift091.protocol.TList(libthrift091.protocol.TType.STRING, iprot.readI32());
          struct.projections = new ArrayList<String>(_list101.size);
          String _elem102;
          for (int _i103 = 0; _i103 < _list101.size; ++_i103)
          {
            _elem102 = iprot.readString();
            struct.projections.add(_elem102);
          }
        }
        struct.setProjectionsIsSet(true);
      }
      if (incoming.get(3)) {
        struct.consistencyLevel = com.xiaomi.infra.galaxy.sds.thrift.ConsistencyLevel.findByValue(iprot.readI32());
        struct.setConsistencyLevelIsSet(true);
      }
      if (incoming.get(4)) {
        struct.unique = iprot.readBool();
        struct.setUniqueIsSet(true);
      }
      if (incoming.get(5)) {
        struct.throughput = new ProvisionThroughput();
        struct.throughput.read(iprot);
        struct.setThroughputIsSet(true);
      }
      if (incoming.get(6)) {
        struct.slaveThroughput = new ProvisionThroughput();
        struct.slaveThroughput.read(iprot);
        struct.setSlaveThroughputIsSet(true);
      }
      if (incoming.get(7)) {
        struct.exceededThroughput = new ProvisionThroughput();
        struct.exceededThroughput.read(iprot);
        struct.setExceededThroughputIsSet(true);
      }
      if (incoming.get(8)) {
        struct.exceededSlaveThroughput = new ProvisionThroughput();
        struct.exceededSlaveThroughput.read(iprot);
        struct.setExceededSlaveThroughputIsSet(true);
      }
      if (incoming.get(9)) {
        struct.preSplits = iprot.readI32();
        struct.setPreSplitsIsSet(true);
      }
    }
  }

}

